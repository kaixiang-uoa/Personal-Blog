# 前后端分离项目常见问题归纳

## 1. CORS (跨域资源共享) 问题

### 问题描述
前端应用（localhost:3000）向后端API（localhost:3001）发送请求时出现CORS错误，特别是带有`X-CSRF-Token`头的请求被浏览器阻止。

### 原因分析
1. 浏览器的同源策略安全机制阻止了跨域AJAX请求
2. 后端CORS配置不完整，未将`X-CSRF-Token`添加到`allowedHeaders`和`exposedHeaders`列表
3. 跨域请求携带凭证（credentials: true）时需要更严格的CORS配置

### 解决方案
1. 更新后端CORS配置，添加所需的自定义头部：
   ```javascript
   const corsOptions = {
     origin: process.env.ALLOWED_ORIGINS ? process.env.ALLOWED_ORIGINS.split(',') : '*',
     methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
     allowedHeaders: ['Content-Type', 'Authorization', 'X-Request-ID', 'X-CSRF-Token'],
     credentials: true,
     exposedHeaders: ['Content-Type', 'Content-Length', 'Content-Disposition', 'X-Request-ID', 'X-CSRF-Token'],
   };
   ```

2. 配置前端开发环境代理，绕过浏览器的同源策略：
   ```typescript
   // Next.js配置
   async rewrites() {
     return [
       {
         source: '/api/:path*',
         destination: 'http://localhost:3001/api/v1/:path*',
       },
     ];
   }
   ```

3. 更新前端API客户端使用代理URL：
   ```typescript
   this.baseUrl = typeof window !== 'undefined' 
     ? '/api' // 浏览器环境使用代理
     : (process.env.NEXT_PUBLIC_API_URL || "http://localhost:3001/api/v1"); // SSR直连
   ```

### 面试要点
- CORS原理：为什么会有CORS，浏览器如何实现CORS预检请求
- 如何正确配置CORS以支持自定义头部和凭证
- 开发环境与生产环境CORS配置的不同策略
- 代理服务器如何解决CORS问题

## 2. CSRF (跨站请求伪造) 保护

### 问题描述
需要实现CSRF保护以防止恶意网站伪造请求攻击用户账户。

### 原因分析
1. 现代Web应用需要防范CSRF攻击
2. 前后端分离应用中通常使用自定义头部（如X-CSRF-Token）进行CSRF保护
3. 缺少服务器端CSRF令牌验证机制

### 解决方案
1. 创建CSRF中间件验证请求：
   ```javascript
   export const csrfProtection = (options = {}) => {
     return (req, res, next) => {
       // 略过安全方法和特定路径
       if (['GET', 'HEAD', 'OPTIONS'].includes(req.method) || 
           ignorePaths.some(path => req.path.startsWith(path))) {
         // 生成新令牌放入响应头
         const newToken = generateToken();
         res.setHeader(CSRF_HEADER, newToken);
         return next();
       }
       
       // 获取并验证令牌
       const token = req.headers[CSRF_HEADER.toLowerCase()] || (req.body && req.body._csrf);
       if (!token) {
         return res.status(403).json({ message: 'CSRF验证失败' });
       }
       
       // 设置新令牌并继续
       res.setHeader(CSRF_HEADER, generateToken());
       next();
     };
   }
   ```

2. 前端实现CSRF令牌管理，在请求中附加令牌：
   ```typescript
   // 添加CSRF令牌到请求
   if (this.csrfToken && ['post','put','delete','patch'].includes(config.method)) {
     config.headers[CSRF_HEADER] = this.csrfToken;
   }
   ```

### 面试要点
- CSRF攻击原理与危害
- 防御CSRF的不同策略：令牌验证、SameSite Cookie、自定义请求头
- 为何API需要为每个响应生成新的CSRF令牌
- 前后端分离架构中的CSRF保护实现

## 3. JWT认证与刷新令牌

### 问题描述
需要实现安全的JWT认证机制，包括令牌刷新功能，避免用户频繁登录。

### 原因分析
1. JWT访问令牌通常设置较短的有效期（如30分钟）以减少被盗用的风险
2. 短期令牌会导致用户体验问题，需要频繁重新登录
3. 刷新令牌机制可以在不要求用户重新登录的情况下获取新的访问令牌

### 解决方案
1. 实现令牌生成函数，创建访问令牌和刷新令牌：
   ```javascript
   // 生成短期访问令牌
   const generateToken = (id) => {
     return jwt.sign({ id }, process.env.JWT_SECRET, {
       expiresIn: process.env.JWT_EXPIRES_IN || '30d'
     });
   };
   
   // 生成长期刷新令牌
   const generateRefreshToken = (id) => {
     return jwt.sign({ id, type: 'refresh' }, process.env.JWT_REFRESH_SECRET, {
       expiresIn: process.env.JWT_REFRESH_EXPIRES_IN || '90d'
     });
   };
   ```

2. 实现令牌刷新端点，验证刷新令牌并签发新令牌：
   ```javascript
   export const refreshToken = async (req, res) => {
     try {
       // 验证刷新令牌
       const decoded = jwt.verify(req.body.refreshToken, process.env.JWT_REFRESH_SECRET);
       
       // 确认是刷新令牌类型
       if (decoded.type !== 'refresh') {
         return res.status(401).json({ message: '无效的刷新令牌' });
       }
       
       // 生成新令牌对
       const newAccessToken = generateToken(decoded.id);
       const newRefreshToken = generateRefreshToken(decoded.id);
       
       res.status(200).json({
         token: newAccessToken,
         refreshToken: newRefreshToken
       });
     } catch (error) {
       // 令牌验证错误处理
     }
   };
   ```

3. 前端自动处理令牌刷新逻辑：
   ```typescript
   // 在响应拦截器中处理401错误
   if (error.response?.status === 401 && TokenManager.hasRefreshToken()) {
     // 刷新令牌并重试原始请求
     const refreshed = await authService.refreshToken();
     if (refreshed) {
       // 使用新令牌重试
       return this.axios(originalRequest);
     }
   }
   ```

### 面试要点
- JWT的结构与工作原理
- 访问令牌与刷新令牌的设计思想
- 令牌轮换(token rotation)的安全性考量
- JWT认证系统的潜在安全风险与防御措施
- 如何处理令牌盗用场景

## 4. 前端API客户端设计

### 问题描述
需要设计一个健壮的API客户端处理认证、错误处理、CSRF保护等跨切面关注点。

### 原因分析
1. 重复的API调用逻辑会导致代码冗余
2. 认证、错误处理、CSRF保护等逻辑应集中管理
3. 需要统一的请求/响应拦截器处理通用逻辑

### 解决方案
1. 使用单例模式创建API客户端：
   ```typescript
   class ApiClient {
     private static instance: ApiClient;
     
     public static getInstance(): ApiClient {
       if (!ApiClient.instance) {
         ApiClient.instance = new ApiClient();
       }
       return ApiClient.instance;
     }
   }
   ```

2. 实现请求拦截器处理认证和CSRF：
   ```typescript
   this.axios.interceptors.request.use(config => {
     // 添加认证令牌
     const token = TokenManager.getToken();
     if (token) {
       config.headers.Authorization = `Bearer ${token}`;
     }
     
     // 添加CSRF令牌
     if (this.csrfToken && isStateChangingMethod(config.method)) {
       config.headers[CSRF_HEADER] = this.csrfToken;
     }
     
     return config;
   });
   ```

3. 实现响应拦截器处理错误和令牌刷新：
   ```typescript
   this.axios.interceptors.response.use(
     response => {
       // 更新CSRF令牌
       const csrfToken = response.headers[CSRF_HEADER.toLowerCase()];
       if (csrfToken) {
         this.setCsrfToken(csrfToken);
       }
       return response.data;
     },
     async error => {
       // 处理401认证错误
       if (error.response?.status === 401) {
         // 尝试令牌刷新
       }
       
       // 处理403 CSRF错误
       if (error.response?.status === 403 && error.response?.data?.message?.includes('CSRF')) {
         // 刷新CSRF令牌
       }
       
       return Promise.reject(error);
     }
   );
   ```

### 面试要点
- API客户端设计模式与最佳实践
- 如何设计可扩展的错误处理机制
- 拦截器模式在前端的应用
- 如何处理认证与授权的状态管理
- 跨切面关注点(cross-cutting concerns)在前端代码中的处理

## 5. 开发环境与生产环境的不同配置

### 问题描述
开发环境和生产环境需要不同的安全配置策略。

### 原因分析
1. 开发环境需要更宽松的安全策略以方便调试
2. 生产环境需要严格的安全配置
3. 环境特定的配置应该可以通过环境变量控制

### 解决方案
1. 使用环境变量区分配置：
   ```javascript
   // CSRF中间件配置
   app.use(csrfProtection({ 
     enforceInDevelopment: process.env.NODE_ENV === 'production' // 仅在生产环境强制执行
   }));
   ```

2. 开发环境API代理：
   ```typescript
   // 仅在开发环境配置API代理
   if (process.env.NODE_ENV === 'development') {
     // 配置开发服务器代理
   }
   ```

3. 基于环境的错误处理：
   ```javascript
   if (process.env.NODE_ENV === 'production') {
     // 生产环境中隐藏详细错误
     res.status(500).json({ message: '服务器错误' });
   } else {
     // 开发环境返回详细错误
     res.status(500).json({ message: error.message, stack: error.stack });
   }
   ```

### 面试要点
- 开发与生产环境的安全配置区别
- 环境变量的最佳使用实践
- 如何安全地处理生产环境的敏感信息
- 使用代理服务器解决开发中的跨域问题
- 自动化环境配置与部署策略

## 6. Express-validator 条件校验与中间件用法

### 问题描述
在实际开发中，某些字段（如 title/content）只有在特定条件下（如 status 为 published）才需要必填。如何优雅地实现这种条件校验？如何组织 validation 逻辑？

### 核心知识点
- express-validator 是 Node.js/Express 常用的请求参数校验库
- 校验逻辑应与业务解耦，集中在 rules 文件中
- 条件校验推荐用 .if() 方法实现
- 校验结果统一用 validationResult 处理

### 推荐目录结构
```
Back-end/
├── src/
│   ├── routers/
│   │   └── postRouters.js
│   ├── utils/
│   │   └── validationRules.js
│   ├── middleware/
│   │   └── validationMiddleware.js
```

### 典型实现流程
1. **定义校验规则（rules）**
   - 在 utils/validationRules.js 里集中定义所有校验规则
   - 用 .if() 实现条件校验
   ```js
   // utils/validationRules.js
   import { body } from 'express-validator';
   export const postRules = {
     create: [
       body('title')
         .if(body('status').equals('published'))
         .notEmpty().withMessage('Title is required'),
       body('content')
         .if(body('status').equals('published'))
         .notEmpty().withMessage('Content is required'),
       // ... 其他校验
     ]
   };
   ```

2. **创建统一校验中间件**
   - 在 middleware/validationMiddleware.js 里用 validationResult 统一处理校验结果
   ```js
   // middleware/validationMiddleware.js
   import { validationResult } from 'express-validator';
   export const validate = (validations) => {
     return async (req, res, next) => {
       for (let validation of validations) {
         await validation.run(req);
       }
       const errors = validationResult(req);
       if (errors.isEmpty()) return next();
       // 格式化并返回错误
       return res.status(400).json({
         success: false,
         errors: errors.array().map(e => ({ field: e.path, message: e.msg, value: e.value })),
         message: 'Validation failed'
       });
     };
   };
   export const validateRequest = (validations) => validate(validations);
   ```

3. **在路由中应用校验中间件**
   - 在 router 文件中引入 rules 和 validateRequest
   ```js
   // routers/postRouters.js
   import { postRules } from '../utils/validationRules.js';
   import { validateRequest } from '../middleware/validationMiddleware.js';
   router.post('/', protect, restrictTo('admin', 'author'), validateRequest(postRules.create), createPost);
   ```

### 最佳实践
- 条件校验逻辑应全部写在 rules 文件里，middleware 只负责统一处理
- 便于维护和复用，业务逻辑和校验逻辑解耦
- 便于单元测试和团队协作

### 面试要点
- express-validator 的基本用法和原理
- 如何实现条件校验（.if()）
- validationResult 的作用和用法
- 为什么要把校验逻辑和业务逻辑分离

## 总结

在前后端分离架构中，安全性和用户体验需要平衡考虑。CORS、CSRF保护和JWT认证是构建安全Web应用的基础。正确实现这些机制不仅能保护用户数据安全，还能提供流畅的用户体验。

开发人员应该理解这些安全机制的工作原理，而不仅仅是照搬实现代码。深入理解有助于在面对新的安全挑战时做出正确的设计决策。
